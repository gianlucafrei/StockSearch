from datetime import date
import simplejson as json

from utils import *

"""

    author: Gian-Luca Frei & Fedor Gamper
    date: 30.05.2018
    project: Stocksearch

    This module provides classes to represent the abstract syntax tree (AST) of
    a query and to execute them.

    The AST is normally generated by using the parser module, but for testing we also
    compose the objects manually together.

    There are different kind of classes:

    Statements:

    There are two (three) different statement classes. Each statement class has a method execute(self, db_connection).
    This method needs an open database connection and will return a result object.

    - AllWhereStatement:    Returns a table result with all shares matching the condition
    - AllStatement:         Returns all shares
    - GetStatement:         Returns the detail data of a share

    Condition:
    A condition object represents a filter for shares. There are three kind of condition:

    - ParenthesedCondition:     Simply a condition with a parenthesis
    - CombinedCondition:        This condition combines two other conditions with AND or OR
    - FunctionCompareCondition: Creates a condition by comparing the values of two functions of a share

    Function:
    A function mapes each share to a number. For example change from x to y
    mapes each share to its value change in the range.

    - Value:    This function returns the value of a share
    - Change:   Returns the value change of a share in a given timeperiod
    - Decimal:  This function mapes each share to a constant number

    There are many other classes, please also see the docs of them.
"""


"""
    Here we have the definitions of the database rows and columns.
    It a name changes, you could simply change the names here
"""
# Table for the shares metadata
shares = Table('stocksearch."Share"',
                key="key",
                name="name",
                isin="isin",
                datasource="dataSource",
                cur="currency",
                desc="description",
                first="start",
                last="end")

# Table with the date, value, share tribles
values = Table('stocksearch."ShareData"', key="key", day="day", val="value", origin='origin')

# The Table which abstracts the calendar
calendar = Table('stocksearch."Calendar"', day='day', date='date')

# This table is not in the database, but used for the function joins.
func = Table("func", key="key", val="value")

class SQL_Select():
    """
    Represents a SQL-Select statement and is used to
    create complex sql statement step by step.
    """
    def __init__(self, *fields):
        self.selects = []
        self.function_counter = 0
        self.functions = []
        self.joins = []

        for f in fields:
            self.select(f)

    def select(self, fieldname):
        """
        Adds a field in the SELECT part of the statement.
        """
        select = f'"share".{fieldname} as {fieldname}'
        self.selects.append(select)
        return self

    def condition_template(self, template):
        """
        Adds the template to the WHERE part.
        """
        self.template = template

    def add_function(self, function):
        """
        Adds a function to the statement. This will
        add a JOIN to the statement
        """
        self.function_counter += 1

        inner_sql = function.get_inner_select()
        name = f'f{self.function_counter}'
        description = str(function)

        self.functions.append(name)
        self.joins.append(f'INNER JOIN ({inner_sql}) as "{name}" ON "share"."key"="{name}"."key"')

        if not isinstance(function, Decimal):
            select = f'"{name}".{func.val} as "{description}"'
            self.selects.append(select)

    def sql(self):
        """
        Returns a sql string of the statement
        """
        fields = ",".join(self.selects)
        condition = self.template.format(*self.functions)

        sql = f'SELECT {fields} FROM {shares} as "share"'

        for join in self.joins:
            sql += "\n" + join

        sql += f'WHERE {condition}'
        return sql

class Statement(object):
    """
        The base class for a statement. For now this class contains no code,
        and just a dummy superclass of all statements
    """
    def execute(self, db_connection): raise Exception("This template method should be overriden by subclasses")

class AllWhereStatement(Statement):
    """
        This statement selects all shares which matches the given condition.
    """

    def __init__(self, condition):
        """Init the object"""
        self.condition = condition
    
    def get_sql(self):
        """
        Generates the sql statement for this query by assimbling the sql
        with all childerns in the AST
        """
        select = SQL_Select(shares.key, shares.name, shares.cur)

        for f in self.condition.get_functions():
            select.add_function(f)
        
        select.condition_template(self.condition.get_condition_template())

        return select.sql()

    def execute(self, db_connection):
        """
            Executes the statement with the given database connection and returns a
            ExecutementResult object. When the executement fails, the resulting object
            will have the attribute success == False
        """
        sql = None
        try:

            sql = self.get_sql()
            sql_result = db_connection.execute(sql)
            
            result = TableResult()
            result.data = sql_result
            result.sql = sql
            return result

        except Exception as ex:
            result = ErrorResult()
            result.ex_type = str(type(ex))
            result.ex = str(ex)
            result.sql = sql
            return result

        def __str__(self):
            return f"all shares where {self.condition}"

class AllStatement(AllWhereStatement):
    """
        A simple all statement without a condition
        For simplicity we just use a boolean condition which is set to true
    """
    def __init__(self):
        true = BooleanCondition(True)
        super(AllStatement, self).__init__(true)

    def __str__(self):
        return "all shares"

class Function(object):
    """
    Represents a function in the SSQL syntax tree
    """
    pass

class Value(Function):
    """
    This function represents the value of a share on a specific date.

    >>> Value(s(1)).get_inner_select()
    'SELECT "key" AS "key", "value" AS "value" FROM stocksearch."ShareData" WHERE "day" = 1'
    """

    def __init__(self, date):
        """Creates a new function which maps the shares to their values on the given day"""
        self.date = date

    def get_inner_select(self):
        """Returns the sql for the inner select function, used for the sql-joins"""
        key = str(values.key)
        date = self.date.get_sql()
        sql = f'SELECT {key} AS {func.key}, {values.val} AS {func.val} FROM {values} WHERE {values.day} = {date}'
        return sql

    def __str__(self):
        return f"value on {self.date}"

class Change(Function):
    """
        This function calculates the change of a share in a specific timespan

        >>> normalize_sql(Change(Timespan(s(1),s(2))).get_inner_select())
        'SELECT bef."key" AS "key", (aft."value" - bef."value") / NULLIF(bef."value", 0) AS "value" FROM stocksearch."ShareData" AS bef, stocksearch."ShareData" AS aft WHERE bef."key"=aft."key" AND bef."day" = 1 AND aft."day" = 2 AND (aft."value" - bef."value") / NULLIF(bef."value", 0) IS NOT NULL'

        >>> normalize_sql(Change(Timespan(s(1),s(2)), absolute=True).get_inner_select())
        'SELECT bef."key" AS "key", (aft."value" - bef."value") AS "value" FROM stocksearch."ShareData" AS bef, stocksearch."ShareData" AS aft WHERE bef."key"=aft."key" AND bef."day" = 1 AND aft."day" = 2 AND (aft."value" - bef."value") IS NOT NULL'
    """

    def __init__(self, timespan, absolute=False):
        """
        Returns a function which mapes shares to their value change in the given
        timespan. It the absolute=True, the absolut change is returned, otherways
        the relaive change of the value.
        """
        self.timespan = timespan
        self.absolute = absolute

    def get_inner_select(self):

        divison = f'/ NULLIF(bef.{func.val}, 0)'

        """Returns the functions sql used in the sql-joins"""
        start = self.timespan.start.get_sql()
        end = self.timespan.end.get_sql()

        sql=f"""SELECT
	bef.{values.key} AS {func.key},
	(aft.{func.val} - bef.{func.val}) {"" if self.absolute else divison} AS {func.val}
	FROM {values} AS bef, {values} AS aft
	WHERE bef.{values.key}=aft.{values.key}
	AND bef.{values.day} = {start}
	AND aft.{values.day} = {end}
    AND (aft.{func.val} - bef.{func.val}) {"" if self.absolute else divison} IS NOT NULL
    """
        return sql

    def __str__(self):
        return f"change {self.timespan}"

class Timespan(object):
    """
        Represents a timespan with a start and an end.
    """
    def __init__(self, start, end):
        self.start = start
        self.end = end
    
    def __str__(self):
        return f"from {self.start} to {self.end}"

class Always(Timespan):
    """
    This special timepspan represents the whole calendar period
    """
    def __init__(self):
        self.start = s("calendar_start()")
        self.end   = s("calendar_end()")

    def __str__(self):
        return "Always"

class Decimal(Function):
    """
        This function simply returns a constant for each share

    >>> Decimal(12.4).get_inner_select()
    'SELECT "key" AS "key", 12.4 AS "value" FROM stocksearch."Share"'
    """
    def __init__(self, value):
        """Creates a new function which maps all shares to the same constant value"""
        self.value = float(value)

    def get_inner_select(self):
        """Returns the sql string, used in the sql-joins"""
        sql= f'SELECT {shares.key} AS {func.key}, {self.value} AS {func.val} FROM {shares}'
        return sql
    
    def __str__(self):
        return str(self.value)

class Average(Function):
    """
        This function returns the average of the values
        in a given timespan.

        We do this by using the wights 0 and 1 over all data.

        >>> a = Average(Timespan(s(2),s(3)))
        >>> normalize_sql(a.get_inner_select())
        '/* Average from 2 to 3*/ WITH wights as (SELECT key, day, value, CASE WHEN day >= 2 AND day <= 3 THEN 1 ELSE 0 END as wight FROM stocksearch."ShareData" WHERE value > 0) SELECT key as "key", sum(value*wight)/NULLIF(sum(wight),0) as "value" FROM wights GROUP BY key HAVING (sum(value*wight)/NULLIF(sum(wight),0)) IS NOT NULL'
    """
    def __init__(self, timespan):
        self.timespan = timespan

    def get_inner_select(self):
        start = self.timespan.start.get_sql()
        start_desc = str(self.timespan.start)
        end = self.timespan.end.get_sql()
        end_desc = str(self.timespan.end)

        sql = f"""/* Average from {start_desc} to {end_desc}*/
        WITH wights as
            (SELECT
                key,
                day,
                value,
                CASE WHEN day >= {start} AND day <= {end} THEN 1 ELSE 0 END as wight
            FROM {values}
            WHERE
	            value > 0)
        SELECT
            key as {func.key},
            sum(value*wight)/NULLIF(sum(wight),0) as {func.val}
        FROM
            wights
        GROUP BY
            key
        HAVING
            (sum(value*wight)/NULLIF(sum(wight),0)) IS NOT NULL
        """
        return sql

    def __str__(self):
        return f"average {self.timespan}"

class Variance(Function):
    """
        This function returns the variance of a share
        over the normalized values in a given time period,
        but ignores where the value is 0

        >>> v = Variance(Timespan(s(2),s(3)))
        >>> normalize_sql(v.get_inner_select())
        '/*Variance from 2 to 3*/ WITH normalized AS( WITH average as (/* Average from 2 to 3*/ WITH wights as (SELECT key, day, value, CASE WHEN day >= 2 AND day <= 3 THEN 1 ELSE 0 END as wight FROM stocksearch."ShareData" WHERE value > 0) SELECT key as "key", sum(value*wight)/NULLIF(sum(wight),0) as "value" FROM wights GROUP BY key HAVING (sum(value*wight)/NULLIF(sum(wight),0)) IS NOT NULL ) SELECT data.key as "key", data.day as "day", data.value / average.value as "value" FROM stocksearch."ShareData" as data INNER JOIN average on average.key = data.key) /* Here we calculate the variance of the normalized data, but we ingnore the entries where the value is zero */ SELECT key as "key", VARIANCE(value) as "value" FROM normalized WHERE value > 0 AND day >= 2 AND day <= 3 GROUP BY key'
    """
    def __init__(self, timespan):
        self.timespan = timespan

    def get_inner_select(self):
        start = self.timespan.start.get_sql()
        start_desc = str(self.timespan.start)
        end = self.timespan.end.get_sql()
        end_desc = str(self.timespan.end)

        a = Average(self.timespan)
        average = a.get_inner_select()

        sql = f"""/*Variance from {start_desc} to {end_desc}*/
            WITH normalized AS(
            WITH average as
            ({average})
            SELECT
                data.key as "key",
                data.day as "day",
                data.value / average.value as "value"
            FROM stocksearch."ShareData" as data
            INNER JOIN average on average.key = data.key)
            /* Here we calculate the variance 
            of the normalized data, but we ingnore
            the entries where the value is zero */
            SELECT
                key as {func.key},
                VARIANCE(value) as {func.val}
            FROM
                normalized
            WHERE
                value > 0 AND
                day >= {start} AND day <= {end} 
            GROUP BY
                key
        """
        return sql
    
    def __str__(self):
        return f"variance {self.timespan}"

class LongestStrike(Function):
    """
        This function returns the duration of the longest period of each share
        in which this share has grown each day

        >>> l = LongestStrike()
        >>> normalize_sql(l.get_inner_select())
        '/* Longest strike */ select key as "key", CAST (longest_strike("value" ORDER BY "day") AS numeric ) as "value" from stocksearch."ShareData" group by key'
    
        >>> l.timespan = Timespan(s(2), s(3))
        >>> normalize_sql(l.get_inner_select())
        '/* Longest strike */ select key as "key", CAST (longest_strike("value" ORDER BY "day") AS numeric ) as "value" from stocksearch."ShareData" WHERE day >= 2 AND day <= 3 group by key'
    """
    timespan = None
    def __init__(self):
        pass
    
    def get_inner_select(self):

        if self.timespan is None:
            where = ''
        else:
            where = f'WHERE day >= {self.timespan.start.get_sql()} AND day <= {self.timespan.end.get_sql()} '

        sql = f"""/* Longest strike */
        select
            key as {func.key},
            CAST (longest_strike({values.val} ORDER BY {values.day}) AS numeric ) as {func.val}
            from {values}
            {where}
            group by key"""
        return sql
    
    def __str__(self):
        return f"longest strike {self.timespan}"

class Condition(object):
    pass

class FunctionCompareCondition(Condition):
    """
        This condition compares two function with the given comparator
        For instance: Value > 23
    """
    def __init__(self, leftFunction, comparator, rightFunction):
        self.leftFunction = leftFunction
        self.comparator = comparator
        self.rightFunction = rightFunction

    def get_functions(self):
        """Returns a list of the left and right function"""
        return [self.leftFunction, self.rightFunction]

    def get_condition_template(self):
        """Returns string in which one can inject the functin names"""
        return "{} " + self.comparator + " {}"
    
    def __str__(self):
        return f"{self.leftFunction} {self.comparator} {self.description}"

class BooleanCondition(Condition):
    """
        This dummy condition is True or False for each share
    """
    def __init__(self, value):
        """Creates a new condtion which is either true or false for each share"""
        self.value = value

    def get_functions(self):
        """Since this condition doesn't use any conditions this returns an empty list"""
        return []

    def get_condition_template(self):
        """Returns the condition as an sql string"""
        return str(self.value)

    def __str__(self):
        return str(self.value)

class CombinedCondition(Condition):
    """
        Combines two conditions with an AND or OR
    """
    def __init__(self, leftCondition, comperator, rightCondition):
        """
            Creates a new condition by concatenating two other conditions
            with a boolean comperator
        """
        self.leftCondition = leftCondition
        self.comperator = comperator
        self.rightCondition = rightCondition

    def get_functions(self):
        """
            Returns a lust off all functions used in this condition by
            recursively calling get_functions() on all subelements.
        """
        left_functions = self.leftCondition.get_functions()
        right_functions = self.rightCondition.get_functions()
        return left_functions + right_functions

    def get_condition_template(self):
        """Returns string in which one can inject the functin names"""
        left_template = self.leftCondition.get_condition_template()
        right_template = self.rightCondition.get_condition_template()
        return "{} {} {}".format(left_template, self.comperator, right_template)

    def __str__(self):
        return f"{self.leftCondition} {self.comparator} {self.rightCondition}"

class ParenthesedCondition(Condition):
    """
        This conditions becomes important when the order of combines conditions rules
    """
    def __init__(self, innerCondition):
        self.innerCondition = innerCondition
    
    def get_functions(self):
        """
            Returns a lust off all functions used in this condition by
            recursively calling get_functions() on all subelements.
        """
        return self.innerCondition.get_functions()

    def get_condition_template(self):
        """Returns string in which one can inject the functin names"""
        return "({})".format(self.innerCondition.get_condition_template())

    def __str__(self):
        return f"({self.innerCondition})"

class Date(object):
    """
    This class should be used for dates, since we have not all dates in the calendar database.
    The execute_and_set_description(db_connection) method looks up the nearest date in the past and
    sets it to the sql variables value.
    """
    effective_date = None

    def __init__(self, date):
        self.date = date

    def get_sql(self):
        """
        Returns the sql statement which sets the variable on the sql server to the calendar day nr
        of the closest day before the date.
        """
        return f"stocksearch.calendar('{self.date}')"

    def __str__(self):
        return str(self.date)


def s(string):
    """only a shortcut for simpler tests"""
    return StringWrapper(string)

class StringWrapper(object):
    def __init__(self, string):
        self.string = str(string)
    def get_sql(self):
        return self.string
    def __str__(self):
        return self.string

class DetailStatement(Statement):
    """
        This statement return the details of a share
    """
    def __init__(self, id):
        """Returns a statement to get the detail data of a share with the given id"""
        self.id = id

    def get_metadata_sql(self):
        """Returns the sql statement to get the metadata of the share (name, isin, ...)"""
        return f"""SELECT
            s.{shares.key},
            s.{shares.name},
            s.{shares.isin},
            s.{shares.datasource},
            s.{shares.cur},
            s.{shares.desc},
            f.{calendar.date} AS {shares.first},
            l.{calendar.date} AS {shares.last}
        FROM {shares} as s, {calendar} as f, {calendar} as l
        WHERE s.{shares.first}=f.{calendar.day} AND s.{shares.last}=l.{calendar.day}
        AND s.{shares.key}='{self.id}'"""

    def get_data_sql(self, start, end):
        """
        Returns the sql statement to return the data entries of the share
        """
        return f"""SELECT
            v.{values.val},
            c.{calendar.date}
        FROM
            {values} AS v,
            {calendar} AS c
        WHERE 
            v.{values.day} = c.{calendar.day}
            AND v.{values.key}='{self.id}'
            AND v.{values.day} >= stocksearch.calendar('{start}')
            AND v.{values.day} <= stocksearch.calendar('{end}')
            AND v.{values.origin} = 'original'
        ORDER BY v.{values.day}
        """

    def execute(self, db_connection):
        """
        Executes the statement and return a error- or detail-result object.
        """
        sql_metadata = self.get_metadata_sql()

        last_statement = sql_metadata
        try:
            # First get the metadata
            sql_metadata_result = db_connection.execute(sql_metadata)

            if len(sql_metadata_result) !=  1:
                raise Exception("Not found")

            # Copy the items into the result
            result = DetailResult()
            row = sql_metadata_result[0]
            for key, val in row.items():
                result.__dict__[key] = val

            # Execute the sql for the data entries
            sql_data = self.get_data_sql(result.start, result.end)
            last_statement = sql_data
            sql_data_result = db_connection.execute(sql_data)
            result.data = sql_data_result

            result.sql = [sql_data, sql_metadata]
            return result

        except Exception as ex:
            result = ErrorResult()
            result.ex = ex
            result.sql = [sql_data, sql_metadata]
            result.failing_sql_statement = last_statement
            return result




"""
    Here are the result object which provides a
    convinient interface to get the data and metadata from
    the executed queries
"""
def dateconverter(o):
    """
    Used by simplejson this function serializes a date object
    """
    if isinstance(o, date):
        return o.__str__()

class Result(object):
    """
        Baseclass for all result objects
    """
    def jsonify(self):
        """
        Returns a json string of the result object
        """
        return json.dumps(self.__dict__, default=dateconverter)

class TableResult(Result):
    """
    This result is used for the AllWhereStatement
    """
    def __init__(self):
        self.success = True
        self.type = "table"

    def init_rows(self):
        """Sets itself an attribute rows with a array of all row names in the data entriy"""
        self.rows = []
        if date is not None and len(self.data) != 0:
            first_element = self.data[0]
            for key, _ in first_element.items():
                self.rows.append(key)

class DetailResult(Result):
    """
    This statement is used for the DetailStatment
    """
    def __init__(self):
        self.success = True
        self.type = "detail"

class ErrorResult(Result):
    """
    This kind of result indicates a failure.
    Other object might inject additional information.
    """
    def __init__(self):
        self.success = False
        self.type = "error"

if __name__ == "__main__":
    import doctest
    doctest.testmod()